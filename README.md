# Programming-Knowledge

OSI网络模型
    定义：OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互联模型。
          该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即ISO开放系统互连参考模型。
    应用层：常见的协议有:HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等，应用层不仅要提供应用进程所需要的信息交换和远程操作，而且还要作为应    用进程的用户代理，来完成一些为进行信息交换所必需的功能。是用户与网络的接口。该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。
    表示层：主要用于处理两个通信系统中交换信息的表示方式。为上层用户解决用户信息的语法问题。它包括数据格式交换、数据加密与解密、数据压缩    与终端类型的转换。
    会话层：在两个节点之间建立端连接。为端系统的应用程序之间提供了对话控制机制。管理对话。如果在某一时刻只允许一个用户执行一项特定的操作    ，会话层协议就会管理这些操作，如阻止两个用户同时更新数据库中的同一组数据。
    传输层：—常规数据递送－面向连接或无连接。为会话层用户提供一个端到端的可靠、透明和优化的数据传输服务机制。包括全双工或半双工、流控制和    错误恢复服务；传输层把消息分成若干个分组，并在接收端对它们进行重组。不同的分组可以通过不同的连接传送到主机。这样既能获得较高的带宽    ，又不影响会话层。在建立连接时传输层可以请求服务质量，该服务质量指定可接受的误码率、延迟量、安全性等参数，还可以实现基于端到端的流    量控制功能。
    网络层：本层通过寻址来建立两个节点之间的连接，为传输层提供服务的，传送的协议数据单元称为数据包或分组，通过路径选择算法（路由）选择合适的路由和交换节点，正确无误地按照地址将数据包传送给目的端的运输层。它包括通过互连网络来路由和中继数据；除了选择路由之外，网络层还负责建立和维护连接，控制网络上的拥塞以及在必要的时候生成计费信息。当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。常用设备有交换机；
    数据链路层：在此层将数据分帧，并处理流控制。屏蔽物理层，为网络层提供一个数据链路的连接，在一条有可能出差错的物理连接上，进行几乎无     差错的数据传输（差错控制）。为网络层提供服务的，解决两个相邻结点之间的通信问题，传送的协议数据单元称为数据帧。
        数据帧中包含物理地址（又称MAC地址）、控制码、数据及校验码等信息。该层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路转换成对网络层来说无差错的数据链路。此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞。本层指定拓扑结构并提供硬件寻址。常用设备有网卡、网桥、交换机；
    物理层：处于OSI参考模型的最底层。物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以便透明的传送比特流。常用设备有（各    种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。
    数据发送时，从第七层传到第一层，接收数据则相反。
    在传输层的数据叫段，网络层叫包，数据链路层叫帧，物理层叫比特流，这样的叫法叫PDU（协议数据单元）
    
    当用户输入要浏览的网站信息后就由应用层产生相关的数据，通过表示层转换成为计算机可识别的ASCII码，再由会话层产生相应的主机进程传给传输层。传输层将以上信息作为数据并加上相应的端口号信息以便目的主机辨别此报文，得知具体应由本机的哪个任务来处理；在网络层加上IP地址使报文能确认应到达具体某个主机，再在数据链路层加上MAC地址，转成bit流信息，从而在网络上传输。报文在网络上被各主机接收，通过检查报文的目的MAC地址判断是否是自己需要处理的报文，如果发现MAC地址与自己不一致，则丢弃该报文，一致就去掉MAC信息送给网络层判断其IP地址；然后根据报文的目的端口号确定是由本机的哪个进程来处理，这就是报文的解封装过程。
    比喻
        7 应用层：老板
        6 表示层：相当于公司中演示稿老板、替老板写信的助理
        工作比喻
        工作比喻
        5 会话层：相当于公司中收寄信、写信封与拆信封的秘书
        4 传输层：相当于公司中跑邮局的送信职员
        3 网络层：相当于邮局中的排序工人
        2 数据链路层：相当于邮局中的装拆箱工人
        1 物理层：相当于邮局中的搬运工人[1] 
http://www.zhihu.com/question/24002080


异常及异常链
String类
Final,字符串不变性
Stringbuilder StringBuffer
集合 collection和map，
collections工具类 排序
Comparable和comparator 

Comparable 默认规则 需要实现compareto方法
Comparator 临时规则
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class CollectionsDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		List<Student> stuList = new ArrayList<Student>();
		Student liming = new Student("Liming", 20);
		Student zhangsan = new Student("zhangsan", 21);
		Student wangwu = new Student("wangwu", 24);
		stuList.add(wangwu);
		stuList.add(liming);
		stuList.add(zhangsan);
		System.out.println("排序之前：");
		for (Student s : stuList) {
			System.out.println(s.getName() + s.getAge());
		}

		Collections.sort(stuList);
		System.out.println("排序之后：");
		for (Student s : stuList) {
			System.out.println(s.getName() + s.getAge());
		}
		Collections.sort(stuList, new ComparatorDemo());
		System.out.println("使用comprator排序之后：");
		for (Student s : stuList) {
			System.out.println(s.getName() + s.getAge());
		}
		Collections.synchronizedList(stuList);
		Collections.synchronizedMap(new HashMap());
	}

}

Java创建对象的几种方式（重要）：

(1) 用new语句创建对象，这是最常见的创建对象的方法。
(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
(3) 调用对象的clone()方法。
(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。

(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。

常用的对称加密算法有：DES、3DES、RC2、RC4、AES

常用的非对称加密算法有：RSA、DSA、ECC

使用单向散列函数的加密算法：MD5、SHA

java只有值传递没有引用传递

抽象类遵循的原则：

（1）abstract关键字只能修饰类和方法，不能修饰字段。
（2）抽象类不能被实例化（无法使用new关键字创建对象实例），只能被继承。
（3）抽象类可以包含属性，方法，构造方法，初始化块，内部类，枚举类，和普通类一样，普通方法一定要实现，变量可以初始化或不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。
（4）抽象类中的抽象方法（加了abstract关键字的方法）不能实现。
（5）含有抽象方法的类必须定义成抽象类。
 
扩展：抽象类和接口的区别，做个总结吧：
（1）接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。

（2）abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。

（3）在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。

（4）abstract class和interface所反映出的设计理念不同。其实abstract class表示的是"is-a"关系，interface表示的是"has-a"关系。

（5）实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。

（6）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。


父类 子类  继承关系
换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。

      总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。
      
      一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。

2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。

3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。

第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明：

 View Code
 
 事物：保证数据的一致性和完整性
 
 &和&&的区别
 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）
 在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环
 关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查“参数是否为这个对象的引用”；2. 使用instanceof操作符检查“参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。
 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。
 
 如何实现对象克隆？

答：有两种方式：

1.实现Cloneable接口并重写Object类中的clone()方法；

2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。
String s=new String(“xyz”);创建了几个字符串对象？

答：两个对象，一个是静态存储区的"xyz",一个是用new创建在堆上的对象。
Java 中的final关键字有哪些用法？

答：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）
